{"version":3,"file":"super-tabs-container.js","sourceRoot":"","sources":["../../src/components/super-tabs-container.ts"],"names":[],"mappings":"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","sourcesContent":["import {\r\n\tComponent, Renderer2, ElementRef, Input, Output, EventEmitter, ViewChild, ViewEncapsulation,\r\n\tAfterViewInit, OnDestroy, NgZone\r\n} from '@angular/core';\r\nimport { Platform } from 'ionic-angular';\r\nimport { SuperTabsPanGesture } from '../super-tabs-pan-gesture';\r\nimport { SuperTabsConfig } from './super-tabs';\r\n\r\n@Component({\r\n\tselector: 'super-tabs-container',\r\n\ttemplate: '<div #container><ng-content></ng-content></div>',\r\n\tencapsulation: ViewEncapsulation.None\r\n})\r\nexport class SuperTabsContainer implements AfterViewInit, OnDestroy {\r\n\r\n\t/**\r\n\t * Boolean indicating whether swiping is globally enabled\r\n\t * @type {boolean}\r\n\t */\r\n\t@Input()\r\n\tprivate globalSwipeEnabled: boolean;\r\n\r\n\t/**\r\n\t * Component configuration\r\n\t * @type {SuperTabsConfig}\r\n\t */\r\n\t@Input()\r\n\tconfig: SuperTabsConfig;\r\n\r\n\t/**\r\n\t * Number of tabs\r\n\t * @type {number}\r\n\t */\r\n\t@Input()\r\n\ttabsCount: number = 0;\r\n\r\n\t/**\r\n\t * Selected tab index\r\n\t * @type {number}\r\n\t */\r\n\t@Input()\r\n\tselectedTabIndex: number;\r\n\r\n\t/**\r\n\t * Notifies when a tab is selected\r\n\t * @type {EventEmitter<Object>}\r\n\t */\r\n\t@Output()\r\n\ttabSelect: EventEmitter<{ index: number; changed: boolean; }> = new EventEmitter<{ index: number; changed: boolean; }>();\r\n\r\n\t/**\r\n\t * Notifies when the container is being dragged\r\n\t * @type {EventEmitter<TouchEvent>}\r\n\t */\r\n\t@Output()\r\n\tonDrag: EventEmitter<TouchEvent> = new EventEmitter<TouchEvent>();\r\n\r\n\t// View bindings\r\n\r\n\t/**\r\n\t * Container position\r\n\t * @type {number}\r\n\t */\r\n\tcontainerPosition: number = 0;\r\n\r\n\t// View children\r\n\r\n\t/**\r\n\t * The container wrapping all the tabs\r\n\t */\r\n\t@ViewChild('container')\r\n\tcontainer: ElementRef;\r\n\r\n\t/**\r\n\t * Single tab width\r\n\t * @type {number}\r\n\t */\r\n\ttabWidth: number = 0;\r\n\r\n\t/**\r\n\t * Container width (sum of tab widths)\r\n\t * @type {number}\r\n\t */\r\n\tcontainerWidth: number = 0;\r\n\r\n\r\n\t// Animation stuff\r\n\r\n\t/**\r\n\t * Minimum position on x-axis that the container can be at\r\n\t */\r\n\tprivate minPosX: number;\r\n\r\n\t/**\r\n\t * Maximum position on x-axis that the container can be at\r\n\t */\r\n\tprivate maxPosX: number;\r\n\r\n\t/**\r\n\t * Pan gesture controller\r\n\t */\r\n\tprivate gesture: SuperTabsPanGesture;\r\n\r\n\t/**\r\n\t * Set of booleans to indicate whether swiping is enabled on each tab\r\n\t * @type {{}}\r\n\t */\r\n\tprivate swipeEnabledPerTab: { [index: number]: boolean } = {};\r\n\r\n\tconstructor(\r\n\t\tprivate el: ElementRef,\r\n\t\tprivate rnd: Renderer2,\r\n\t\tprivate plt: Platform,\r\n\t\tprivate ngZone: NgZone\r\n\t) { }\r\n\r\n\tngAfterViewInit() {\r\n\t\tthis.init();\r\n\t}\r\n\r\n\tngOnDestroy() {\r\n\t\tthis.gesture && this.gesture.destroy();\r\n\t}\r\n\r\n\t/**\r\n\t * Enable or disable swiping globally\r\n\t * @param enable {boolean} set to true to enable\r\n\t */\r\n\t// enableTabsSwipe(enable: boolean) {\r\n\t// \tthis.globalSwipeEnabled = enable;\r\n\t// }\r\n\r\n\t/**\r\n\t * Enable or disable swiping when a tab is selected\r\n\t * @param tabIndex {number} tab index\r\n\t * @param enable {boolean} set to true to enable\r\n\t */\r\n\tenableTabSwipe(tabIndex: number, enable: boolean) {\r\n\t\tthis.swipeEnabledPerTab[tabIndex] = enable;\r\n\t}\r\n\r\n\trefreshDimensions() {\r\n\t\tthis.calculateContainerWidth();\r\n\t\tthis.setContainerWidth();\r\n\t\tthis.refreshMinMax();\r\n\t}\r\n\r\n\tgetNativeElement(): HTMLElement {\r\n\t\treturn this.el.nativeElement;\r\n\t}\r\n\r\n\tprivate init() {\r\n\r\n\t\tthis.refreshDimensions();\r\n\r\n\t\tthis.gesture = new SuperTabsPanGesture(this.plt, this.container.nativeElement, this.config, this.rnd, this.globalSwipeEnabled);\r\n\r\n\t\tthis.gesture.onMove = (delta: number) => {\r\n\t\t\t// if (this.globalSwipeEnabled === false) return;\r\n\t\t\t// if (this.swipeEnabledPerTab[this.selectedTabIndex] === false) return;\r\n\t\t\tif ((this.containerPosition === this.maxPosX && delta >= 0) || (this.containerPosition === this.minPosX && delta <= 0)) return;\r\n\t\t\tthis.containerPosition += delta;\r\n\t\t\tthis.plt.raf(() => {\r\n\t\t\t\tthis.onDrag.emit();\r\n\t\t\t\tthis.moveContainer();\r\n\t\t\t})\r\n\t\t};\r\n\r\n\t\tthis.gesture.onEnd = (shortSwipe: boolean, shortSwipeDelta?: number) => {\r\n\t\t\t// if (this.globalSwipeEnabled === false) return;\r\n\t\t\t// if (this.swipeEnabledPerTab[this.selectedTabIndex] === false) return;\r\n\r\n\t\t\t// get tab index based on container position\r\n\t\t\tlet tabIndex = Math.round(this.containerPosition / this.tabWidth);\r\n\r\n\t\t\t// handle short swipes\r\n\t\t\t// only short swipe if we didn't change tab already in this gesture\r\n\t\t\t(tabIndex === this.selectedTabIndex) && shortSwipe && ((shortSwipeDelta < 0 && tabIndex++) || (shortSwipeDelta > 0 && tabIndex--));\r\n\r\n\t\t\t// get location based on tab index\r\n\t\t\tconst position = Math.max(this.minPosX, Math.min(this.maxPosX, tabIndex * this.tabWidth));\r\n\r\n\t\t\ttabIndex = position / this.tabWidth;\r\n\r\n\t\t\t// move container if we changed position\r\n\t\t\tif (position !== this.containerPosition) {\r\n\t\t\t\tthis.plt.raf(() =>\r\n\t\t\t\t\tthis.moveContainer(true, position)\r\n\t\t\t\t\t\t.then(() =>\r\n\t\t\t\t\t\t\tthis.ngZone.run(() => this.setSelectedTab(tabIndex))\r\n\t\t\t\t\t\t)\r\n\t\t\t\t);\r\n\t\t\t} else this.setSelectedTab(tabIndex);\r\n\r\n\t\t};\r\n\t}\r\n\r\n\t/**\r\n\t * Set the selected tab.\r\n\t * Emits a tabSelect event with the tab index, and a boolean indicating whether the tab changed or not.\r\n\t * @param index {number} tab index\r\n\t */\r\n\tprivate setSelectedTab(index: number) {\r\n\t\tthis.tabSelect.emit({ index, changed: index !== this.selectedTabIndex });\r\n\t\tthis.selectedTabIndex = index;\r\n\t\tthis.gesture.selectedTabIndex = index;\r\n\t}\r\n\r\n\t/**\r\n\t * Calculate the container's width.\r\n\t * It's usually the number of tabs x tab width.\r\n\t */\r\n\tprivate calculateContainerWidth() {\r\n\t\tthis.containerWidth = this.tabWidth * this.tabsCount;\r\n\t}\r\n\r\n\t/**\r\n\t * Set the container's width via CSS property\r\n\t */\r\n\tprivate setContainerWidth() {\r\n\t\tthis.rnd.setStyle(this.container.nativeElement, 'width', this.containerWidth + 'px');\r\n\t}\r\n\r\n\t/**\r\n\t * Slide to a specific tab\r\n\t * @param index {number} tab index\r\n\t * @param [animate=true] {boolean} set to true to animate\r\n\t */\r\n\tslideTo(index: number, animate: boolean = true): void {\r\n\t\tthis.plt.raf(() => this.moveContainer(animate, index * this.tabWidth));\r\n\t}\r\n\r\n\t/**\r\n\t * Moves the container to a specified position\r\n\t * @param [animate=false] {boolean} set to true to animate\r\n\t * @param [positionX] {number} position on x-axis\r\n\t */\r\n\tprivate async moveContainer(animate: boolean = false, positionX?: number) {\r\n\t\tconst el: HTMLElement = this.container.nativeElement;\r\n\r\n\t\tif (animate) {\r\n\r\n\t\t\tif (el.style[this.plt.Css.transform].indexOf('all') === -1) {\r\n\t\t\t\tthis.rnd.setStyle(el, this.plt.Css.transition, `all ${this.config.transitionDuration}ms ${this.config.transitionEase}`);\r\n\t\t\t}\r\n\r\n\t\t\tthis.rnd.setStyle(el, this.plt.Css.transform, `translate3d(${-1 * positionX}px, 0, 0)`);\r\n\r\n\t\t\tthis.containerPosition = positionX;\r\n\r\n\t\t} else {\r\n\r\n\t\t\tif (positionX) {\r\n\t\t\t\tthis.containerPosition = positionX;\r\n\t\t\t}\r\n\r\n\t\t\tif (el.style[this.plt.Css.transform] !== 'initial') {\r\n\t\t\t\tthis.rnd.setStyle(el, this.plt.Css.transition, 'initial');\r\n\t\t\t}\r\n\r\n\t\t\tthis.containerPosition = Math.max(this.minPosX, Math.min(this.maxPosX, this.containerPosition));\r\n\r\n\t\t\tthis.rnd.setStyle(el, this.plt.Css.transform, `translate3d(${-1 * this.containerPosition}px, 0, 0)`);\r\n\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Refresh the min and max positions that the container can be at.\r\n\t * The minimum position is always 0, the maximum position is the number of tabs x tab width.\r\n\t */\r\n\tprivate refreshMinMax(): void {\r\n\t\tthis.minPosX = 0;\r\n\t\tthis.maxPosX = (this.tabsCount - 1) * this.tabWidth;\r\n\t}\r\n\r\n}\r\n"]}